// cmd/bk/main.go
// Copyright(c) 2017 Matt Pharr
// BSD licensed; see LICENSE for details.

package main

import (
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"github.com/mmp/bk/storage"
	u "github.com/mmp/bk/util"
	"io"
	"io/ioutil"
	"os"
	"os/signal"
	"runtime/pprof"
	"sort"
	"strings"
	"time"
)

var log *u.Logger

func usage() {
	fmt.Printf(`usage: bk [bk flags...] <command> [command args...]
where <command> is: backup, cat, fsck, help, init, list, mount, restore, restorebits, savebits.
Run "bk help" for more detailed help.
`)
	os.Exit(1)
}

func help() {
	fmt.Printf(`
bk is a tool for backing up data.  It can be given the path to a directory
to recursively back up the contents of, or alternatively, it can be given a
bitstream to be backed up from standard input (typically, the output of the
"tar" command). In either case, it stores the resulting data in manner that
minimizes storage requirements for data that is unchanged across multiple
backups and/or is repeated within a single backup.

Environment variables:
- BK_DIR: Directory where backups are stored. If prefixed with "gs://", is taken
  to refer to a Google Cloud Storage bucket.
- BK_GCS_PROJECT_ID: If Google Cloud Storage is being used, the name of the
  project you're using for billing. (Create using the Google Cloud console).
- BK_PASSPHRASE: if encryption is being used, the encryption passphrase.

usage: bk [bk flags...] <command> [command_options ...]

General bk flags are: [--verbose] [--debug] [--profile] [--memprofile]

Commands and their options are:
  backup [--split-bits count] [--base base] [--exclude path] <backup name> <directory>
      Make a back up of <directory>, including the contents of all
      subdirectories, with the given name in the given bk repository.  The
      --split-bits option can be used to control how large the blobs
      generated by the splitting algorithm are, and --base can be used to
      specify a base backup for incremental backups. The --exclude option
      (which may be used multiple times) specifies paths to exclude from
      backups.
           
  cat <hash ...>
      Prints the contents of the given hash(es) to standard output.

  fsck
      Check integrity of the bk repository.

  help
      Prints this help message.

  init [--encrypt]
      Initialize a new backup repository in the given directory. If backups
      in this repository should be encrypted, the --encrypt option should
      be given.

  list
      List names of all backups and archived bitstreams.

  mount <dir>
      Mounts all available backups at the provided directory.

  restore <backup name> <target dir>
      Restore the named backup to the specified target directory.

  restorebits <bits name>
      Restore the named bitstream, printing its contents to standard output.

  savebits [--split-bits bits] <bits name>
      Save the bitstream given in standard input to the given name.

`)
	os.Exit(0)
}

func lookupHash(name string, backend storage.Backend) (hash storage.Hash) {
	if !backend.MetadataExists(name) {
		fmt.Fprintf(os.Stderr, "%s: backup not found\n", name)
		os.Exit(1)
	}

	b := backend.ReadMetadata(name)
	return storage.NewHash(b)
}

func Error(s string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, s, args...)
	os.Exit(1)
}

func InitStorage(encrypt bool) {
	backend := getBaseBackend()
	if encrypt {
		passphrase := os.Getenv("BK_PASSPHRASE")
		if passphrase == "" {
			Error("BK_PASSPHRASE environment variable not set.\n")
		}
		backend = storage.NewEncrypted(backend, passphrase)
	}
	backend = storage.NewCompressed(backend)

	backend.WriteMetadata("readme_bk.txt", []byte(readmeText))
	backend.SyncWrites()
}

func getBaseBackend() storage.Backend {
	path := os.Getenv("BK_DIR")
	if path == "" {
		Error("BK_DIR: environment variable not set.\n")
	}

	if strings.HasPrefix(path, "gs://") {
		projectId := os.Getenv("BK_GCS_PROJECT_ID")
		if projectId == "" {
			Error("BK_GCS_PROJECT_ID environment variable not set.\n")
		}
		return storage.NewGCS(storage.GCSOptions{
			BucketName: strings.TrimPrefix(path, "gs://"),
			ProjectId:  projectId,
			// TODO: make it possible to specify these via command-line
			// args.
			MaxUploadBytesPerSecond:   900 * 1024,
			MaxDownloadBytesPerSecond: 5 * 1024 * 1024,
		})
	}
	return storage.NewDisk(path)
}

func GetStorageBackend() storage.Backend {
	backend := getBaseBackend()
	if backend.MetadataExists("encrypt.txt") {
		passphrase := os.Getenv("BK_PASSPHRASE")
		if passphrase == "" {
			Error("BK_PASSPHRASE environment variable not set.\n")
		}
		backend = storage.NewEncrypted(backend, passphrase)
	}
	backend = storage.NewCompressed(backend)

	if !backend.MetadataExists("readme_bk.txt") {
		Error("%s: destination hasn't been initialized. Run 'bk init'.\n",
			backend.String())
	}

	return backend
}

func getLatest(name string, backend storage.Backend) (string, error) {
	if backend.MetadataExists(name) {
		return name, nil
	} else if !strings.Contains(name, "@") {
		// Find the most recent instance with this name.
		var latestName string
		var latestTime time.Time
		for n, t := range backend.ListMetadata() {
			if strings.HasPrefix(n, name) && t.After(latestTime) {
				latestName = n
				latestTime = t
			}
		}
		if latestName != "" {
			return latestName, nil
		}
	}

	return "", errors.New("metadata not found")
}

///////////////////////////////////////////////////////////////////////////

func main() {
	if len(os.Args) < 2 {
		usage()
	}

	debug := false
	verbose := false
	profile := false
	memprofile := false
	idx := 1
	for os.Args[idx][0] == '-' {
		switch os.Args[idx] {
		case "--debug":
			debug = true
			verbose = true
			idx++
		case "--verbose":
			verbose = true
			idx++
		case "--memprofile":
			memprofile = true
			idx++
		case "--profile":
			profile = true
			idx++
		default:
			usage()
		}
	}
	log = u.NewLogger(verbose, debug)
	storage.SetLogger(log)

	cmd := os.Args[idx]
	idx++

	if profile {
		log.Print("Starting profiling.")
		f, err := os.Create("bk.prof")
		log.CheckError(err)
		pprof.StartCPUProfile(f)

		go func() {
			sigchan := make(chan os.Signal, 10)
			signal.Notify(sigchan, os.Interrupt)
			<-sigchan
			pprof.StopCPUProfile()
			os.Exit(0)
		}()
	} else if memprofile {
		go func() {
			log.Print("Will write memory profile when SIGINT is received.")
			sigchan := make(chan os.Signal, 10)
			signal.Notify(sigchan, os.Interrupt)
			<-sigchan
			f, err := os.Create("bk.memprof")
			if err != nil {
				log.Fatal("%s", err)
			}
			pprof.WriteHeapProfile(f)
			os.Exit(0)
		}()
	}

	// Dispatch to the appropriate command.
	switch cmd {
	case "help":
		help()
	case "backup":
		backup(os.Args[idx:])
	case "cat":
		cat(os.Args[idx:])
	case "fsck":
		fsck(os.Args[idx:])
	case "init":
		initcmd(os.Args[idx:])
	case "list":
		list(os.Args[idx:])
	case "mount":
		mount(os.Args[idx:])
	case "restore":
		restore(os.Args[idx:])
	case "restorebits":
		restorebits(os.Args[idx:])
	case "savebits":
		savebits(os.Args[idx:])
	default:
		usage()
	}

	if profile {
		pprof.StopCPUProfile()
	}

	os.Exit(log.NErrors)
}

///////////////////////////////////////////////////////////////////////////

type stringSlice []string

// Implement the flag.Value interface.
func (s *stringSlice) String() string {
	var ret string
	for _, v := range *s {
		ret += v
		ret += " "
	}
	return ret
}

func (s *stringSlice) Set(value string) error {
	*s = append(*s, value)
	return nil
}

func backup(args []string) {
	// Parse args
	flags := flag.NewFlagSet("backup", flag.ExitOnError)
	flags.Usage = func() {
		Error("usage: bk backup [--base name] [--split-bits count] [--exclude name] <name> <dir>\n")
	}
	base := flags.String("base", "", "base backup (for incremental backups)")
	splitBits := flags.Uint("split-bits", 14,
		"matching bits for rolling checksum")
	var excludedPaths stringSlice
	flags.Var(&excludedPaths, "exclude", "Paths to exclude from backups")
	err := flags.Parse(args)
	if err == flag.ErrHelp || flags.NArg() != 2 {
		flags.Usage()
	} else if err != nil {
		Error("%s\n", err)
	}

	backend := GetStorageBackend()
	name := flags.Arg(0) + "@" + time.Now().Format("20060102150405")
	dir := flags.Arg(1)

	log.Check(!backend.MetadataExists("backup-" + name))

	var hash storage.Hash
	if *base != "" {
		*base, err = getLatest("backup-"+*base, backend)
		if err != nil {
			Error("--base: %s\n", err)
		}
		baseHash := lookupHash(*base, backend)
		hash, err = BackupDirIncremental(dir, baseHash, backend, *splitBits, excludedPaths)
		log.CheckError(err)
	} else {
		hash, err = BackupDir(dir, backend, *splitBits, excludedPaths)
		log.CheckError(err)
	}

	// Get all of the data on disk before we save the named hash.
	backend.SyncWrites()

	backend.WriteMetadata("backup-"+name, hash[:])
	backend.SyncWrites()

	log.Print("%s: successfully saved backup: %s", name, hash)
	backend.LogStats()
}

///////////////////////////////////////////////////////////////////////////

func cat(args []string) {
	if len(args) == 0 {
		Error("usage: bk cat <hash ...>\n")
	}

	backend := GetStorageBackend()
	for _, arg := range args {
		h, err := hex.DecodeString(arg)
		if err != nil {
			Error("%s: %s\n", arg, err)
		}
		if len(h) != storage.HashSize {
			Error("%s: given %d bytes, expected %d\n", arg, len(h),
				storage.HashSize)
		}
		var hash storage.Hash
		copy(hash[:], h)

		r, err := backend.Read(hash)
		if err != nil {
			Error("%s: %s\n", arg, err)
		}
		b, err := ioutil.ReadAll(r)
		if err != nil {
			Error("%s: %s\n", arg, err)
		}
		fmt.Print(string(b))
		r.Close()
	}

	backend.LogStats()
}

///////////////////////////////////////////////////////////////////////////

func fsck(args []string) {
	if len(args) != 0 {
		Error("usage: bk fsck <bk dir>\n")
	}

	backend := GetStorageBackend()

	for name := range backend.ListMetadata() {
		if strings.HasPrefix(name, "bits-") {
			log.Debug("Checking %s", name)
			b := backend.ReadMetadata(name)
			sh := storage.NewMerkleHash(b)
			sh.Fsck(backend)
		} else if strings.HasPrefix(name, "backup-") {
			h := lookupHash(name, backend)
			log.Debug("Checking %s. Hash %s", name, h)
			r, err := NewBackupReader(h, backend)
			if err != nil {
				log.Error("%s\n", err)
			}
			r.Fsck()
		}
	}

	// Let the storage do its thing.
	backend.Fsck()

	backend.LogStats()
}

///////////////////////////////////////////////////////////////////////////

func initcmd(args []string) {
	if len(args) == 1 && args[0] == "--encrypt" {
		InitStorage(true)
	} else if len(args) == 0 {
		InitStorage(false)
	} else {
		Error("usage: bk init [--encrypt]\n")
	}
}

///////////////////////////////////////////////////////////////////////////

func list(args []string) {
	if len(args) != 0 {
		Error("usage: bk list\n")
	}

	backend := GetStorageBackend()
	md := backend.ListMetadata()

	var backups, bits []string
	for n := range md {
		if strings.HasPrefix(n, "bits-") {
			bits = append(bits, n)
		} else if strings.HasPrefix(n, "backup-") {
			backups = append(backups, n)
		}
	}

	if len(backups) > 0 {
		sort.Strings(backups)
		fmt.Printf("Total of %d backups:\n", len(backups))
		for _, name := range backups {
			fmt.Printf("  %-30s %s\n",
				strings.TrimPrefix(name, "backup-"), md[name].String())
		}
	}
	if len(bits) > 0 {
		sort.Strings(bits)
		fmt.Printf("Total of %d bitstreams:\n", len(bits))
		for _, name := range bits {
			fmt.Printf("  %-30s %s\n",
				strings.TrimPrefix(name, "bits-"), md[name].String())
		}
	}
}

///////////////////////////////////////////////////////////////////////////

func mount(args []string) {
	if len(args) != 1 {
		Error("usage: bk mount <dir>\n")
	}

	backend := GetStorageBackend()

	var nb []namedBackup
	for name, time := range backend.ListMetadata() {
		if strings.HasPrefix(name, "backup-") {
			b := backend.ReadMetadata(name)
			r, err := NewBackupReader(storage.NewHash(b), backend)
			if err != nil {
				log.Error("%s\n", err)
			}
			n := strings.TrimPrefix(name, "backup-")
			nb = append(nb, namedBackup{n, time, r})
		}
	}

	mountFUSE(args[0], nb)
}

///////////////////////////////////////////////////////////////////////////

func restore(args []string) {
	if len(args) != 2 {
		Error("usage: bk restore <name> <dir>\n")
	}

	backend := GetStorageBackend()
	name, err := getLatest("backup-"+args[0], backend)
	if err != nil {
		log.Error("%s\n", err)
	}

	b := backend.ReadMetadata(name)
	r, err := NewBackupReader(storage.NewHash(b), backend)
	if err != nil {
		log.Error("%s\n", err)
	}

	if err = r.Restore("/", args[1]); err != nil {
		log.Error("%s\n", err)
	}
	backend.LogStats()
}

///////////////////////////////////////////////////////////////////////////

func restorebits(args []string) {
	if len(args) != 1 {
		Error("usage: bk restorebits <backup name>\n")
	}

	backend := GetStorageBackend()

	name, err := getLatest("bits-"+args[0], backend)
	if err != nil {
		Error("%s: %s\n", name, err)
	}

	hash := storage.NewMerkleHash(backend.ReadMetadata(name))

	r := hash.NewReader(nil, backend)
	// Write the blob contents to stdout.
	rr := &u.ReportingReader{R: r, Msg: "Restored"}
	if _, err := io.Copy(os.Stdout, rr); err != nil {
		Error("%s: %s\n", name, err)
	}
	if err = rr.Close(); err != nil {
		Error("%s: %s\n", name, err)
	}

	backend.LogStats()
}

///////////////////////////////////////////////////////////////////////////

func savebits(args []string) {
	// Parse args
	flags := flag.NewFlagSet("savebits", flag.ExitOnError)
	flags.Usage = func() {
		Error("usage: bk savebits [--split-bits bits] <backup name>\n")
	}
	splitBits := flags.Uint("split-bits", 14,
		"matching bits for rolling checksum")
	err := flags.Parse(args)
	if err == flag.ErrHelp || flags.NArg() != 1 {
		flags.Usage()
	} else if err != nil {
		Error("%s\n", err)
	}

	backend := GetStorageBackend()
	name := flags.Arg(0) + "@" + time.Now().Format("20060102150405")
	log.Check(!backend.MetadataExists("bits-" + name))

	r := &u.ReportingReader{R: os.Stdin, Msg: "Read"}
	backupHash := storage.SplitAndStore(r, backend, *splitBits)
	r.Close()

	// Sync before saving the named hash.
	backend.SyncWrites()

	backend.WriteMetadata("bits-"+name, backupHash.Bytes())
	backend.SyncWrites()

	log.Print("%s: successfully saved bits", name)
	backend.LogStats()
}
